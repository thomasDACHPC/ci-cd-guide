# Local Kubernetes Setup
## Prerequisites and System used for this Guide
- macOS Somna Version 14.5
- Docker with DockerID
  `brew install --cask docker`
- Minikube
  `brew install minikube`
- kubectl
  `brew install kubectl`
- Java 17 or later
- Maven

## Java Spring Web Application

### Fork the [CI/CD-Guide Project](https://github.com/thomasDACHPC/ci-cd-guide/tree/main)
The example project contains a simple Java Spring Web Application in
`src/main/java/com/example/spring_boot_docker/SpringBootDockerApplication.java`:
```
package com.example.spring_boot_docker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class SpringBootDockerApplication {

	@RequestMapping("/")
	public String home() {
		return "Hello from the Kubernetes Cluster!";
	}

	public static void main(String[] args) {
		SpringApplication.run(SpringBootDockerApplication.class, args);
	}
}
```
When started, accessing [`http://localhost:8080/`]() will display the message *Hello from the Kubernetes Cluster!*.\
At the moment this statement is incorrect, but this will change when following this guide. Stop the application again before continuing.



### Package the Java Application
Use `./mvnw package` withing the project to package the application as .jar file.

## Containerization of the Application with Docker

### Write a Dockerfile to create an Docker Image of the Application
After packaging the application the next step is to containerize it and create an image.
In this guide a Dockerfile is used for this process.
Create a file called `Dockerfile` with the following content:
```
FROM amazoncorretto:21.0.4-alpine3.18
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```
This Dockerfile is used to set up a Java environment and copy our application into this environment. The entry point ensures that the application is executed directly when the container is started.

### Build the Docker Image
`docker build . -t spring-boot-app`\
The `-t` option tags the image as ***spring-boot-app***
Note that the docker deamon has to run to execute the command (i.e. start Docker Desktop for example)

### Run a Docker Container (Optional)
You can test if the imaging process was successfull by running the command\
`docker run -p 8080:8080 <image-id>`\
Again, accessing [`http://localhost:8080/`]() should display the message *Hello from the Kubernetes Cluster!*. But the message is still not true. Currently the application runs in a container.
Please shut down the container before continuing.

### Push the Image to the Docker Container Registry (DockerID required)
Use the following command to push the image to the Docker Container Registry (Docker Hub). To be compliant with this gude use `cicdguideproject:v1.0.0` as `<docker-repository-name>:<tag>`
```
docker tag <current-image-name> <docker-id>/<docker-repository-name>:<tag>
docker push <docker-id>/<docker-repository-name>:<tag>
```
The first command changes the name of the image and adds an optional tag (for example for versioning). The second command actually pushes the image to the container registry.

## Kubernetes
Now we are accessing the the universe of Kubernetes. Kubernetes, often abbreviated as K8s, is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. 
### Core Components of Kubernetes (generated by ChatGPT)
- **Cluster**: The set of nodes (machines) that run containerized applications managed by Kubernetes.
- **Node**: A single machine in the Kubernetes cluster. It runs containerized applications and is managed by the control plane.
- **Pod**: The smallest deployable unit in Kubernetes, which can contain one or more containers. Pods are designed to run a single instance of a given application.
- **Deployment**: A Kubernetes resource that manages a set of identical pods, ensuring the correct number of pods are running and updating them as needed.
- **Service**: An abstraction that defines a logical set of pods and a policy by which to access them, usually via an IP address or DNS name.
- **Namespace**: A way to divide cluster resources between multiple users. Namespaces are a way to organize objects in the cluster and are often used for multi-tenant environments.


### Create a Kubernetes Deployment File (deployment.yaml)
To tell Kubernetes which application and how many pods should be deployed a deployment configuration is necesseray. A simple `deployment.yaml` file can be found in the project folder `deployment`.
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app-deployment
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
        - name: spring-boot-app
          image: thomasdachpc/cicdguideproject:v1.0.0
          ports:
            - containerPort: 8080
```
A few comments on this file:

---
```
metadata:
	name: spring-boot-app-deployment
	namespace: default
```

Sets a unique name for the deployment and its namespace. For this guide, do not change the namespace.

---
```
replicas: 2
```
Defines how many pods of the application should be created by Kubernetes.

---
```
containers:
	- name: spring-boot-app
    	image: thomasdachpc/cicdguideproject:v1.0.0
        ports:
        	- containerPort: 8080
```
These lines of code set the application image which should be deployed by Kubernetes. The *image* is equivalent to `<docker-repository-name>:<tag>` in this case. 
The *containerPort* defines the port on which the application is accessible.

---

For more information about deployments refer to the Kubernetes documentation! 


### Create a Kubernetes Service File (service.yaml)
The next part is about the configuration of a service. Again, a simple `service.yaml` file can be found in the project folder `deployment`.
```
apiVersion: v1
kind: Service
metadata:
  name: spring-boot-app-service
  namespace: default
spec:
  type: LoadBalancer
  selector:
    app: spring-boot-app
  ports:
    - protocol: TCP
      port: 81
      targetPort: 8080
```

Metadata contains the unique name of the service as well as its namesace. Again, the namespace should not be changed. 


### Apply the configuration files
```
kubectl apply -f gitDeployment/deployment.yaml
kubectl apply -f gitDeployment/service.yaml
```
### Check status
```
kubectl get all
```
### Create a Routable IP
``` 
minikube tunnel
```