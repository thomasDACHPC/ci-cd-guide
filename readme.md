# Local Kubernetes Setup
## Prerequisites and System used for this Guide
- macOS Somna Version 14.5
- Docker with DockerID
  `brew install --cask docker`
- Minikube
  `brew install minikube`
- kubectl
  `brew install kubectl`
- Java 17 or later
- Maven

## Java Spring Web Application

### Fork the [CI/CD-Guide Project](https://github.com/thomasDACHPC/ci-cd-guide/tree/main)
The example project contains a simple Java Spring Web Application in
`src/main/java/com/example/spring_boot_docker/SpringBootDockerApplication.java`:
```
package com.example.spring_boot_docker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class SpringBootDockerApplication {

	@RequestMapping("/")
	public String home() {
		return "Hello from the Kubernetes Cluster!";
	}

	public static void main(String[] args) {
		SpringApplication.run(SpringBootDockerApplication.class, args);
	}
}
```
When started, accessing [`http://localhost:8080/`]() will display the message returned by the *RequestMapping("/")-Method*. 
Stop the application before continuing.

### Package the Java Application
Use `./mvnw package` withing the project to package the application as .jar file.

## Containerization of the Application with Docker

### Write a Dockerfile to create an Docker Image of the Application
After packaging the application the next step is to containerize it and create an image.
In this guide a Dockerfile is used for this process.
Create a file called `Dockerfile` with the following content:
```
FROM amazoncorretto:21.0.4-alpine3.18
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```
This Dockerfile is used to set up a Java environment and copy our application into this environment. The entry point ensures that the application is executed directly when the container is started.

### Build the Docker Image
`docker build . -t spring-boot-app`\
The `-t` option tags the image as ***spring-boot-app***.
Note that the docker deamon has to run to execute the command (i.e. start Docker Desktop for example)

### Run a Docker Container (Optional)
You can test if the imaging process was successfull by running the command\
`docker run -p 8080:8080 <image-id>`\
Again, accessing [`http://localhost:8080/`]() will display the message returned by the *RequestMapping("/")-Method*.
Please shut down the container before continuing.

### Push the Image to the Docker Container Registry (DockerID required)
Use the following command to push the image to the Docker Container Registry (Docker Hub). To be compliant with this gude use `cicdguideproject:v1.0.0` as `<docker-repository-name>:<tag>`.
`<docker-id>` is your docker username.
```
docker tag <current-image-name> <docker-id>/<docker-repository-name>:<tag>
docker push <docker-id>/<docker-repository-name>:<tag>
```
The first command changes the name of the image and adds an optional tag (for example for versioning). The second command actually pushes the image to the container registry.

## Kubernetes
Now we are accessing the the universe of Kubernetes. Kubernetes, often abbreviated as K8s, is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. 
### Core Components of Kubernetes (generated by ChatGPT)
- **Cluster**: The set of nodes (machines) that run containerized applications managed by Kubernetes.
- **Node**: A single machine in the Kubernetes cluster. It runs containerized applications and is managed by the control plane.
- **Pod**: The smallest deployable unit in Kubernetes, which can contain one or more containers. Pods are designed to run a single instance of a given application.
- **Deployment**: A Kubernetes resource that manages a set of identical pods, ensuring the correct number of pods are running and updating them as needed.
- **Service**: An abstraction that defines a logical set of pods and a policy by which to access them, usually via an IP address or DNS name.
- **Namespace**: A way to divide cluster resources between multiple users. Namespaces are a way to organize objects in the cluster and are often used for multi-tenant environments.

### Setup Minikube on MacOs
Minikube is an open-source tool that allows you to run a single-node Kubernetes cluster on your local machine.
Minikube uses a hypervisor to create a virtual machine or a container runtime to simulate a Kubernetes environment.
Due to the limitations of the Docker driver on Apple Silicon Chips we will use a QEMU driver for virtualization.
The following commands will install QEMU and *socket_vmnet* which will allow Minikube to run `minikube tunnel` command if needed.
```
brew install qemu
brew install socket_vmnet
brew tap homebrew/services
HOMEBREW=$(which brew) && sudo ${HOMEBREW} services start socket_vmnet
```
The minikube cluster ist started with\
`minikube start --driver qemu --network socket_vmnet`.

### Prepare Minikube for Kubernetes Ingress
Later in this guide we will establish a Kubernetes Ingress. A corresponding addon has to be enabled in Minikube\
`minikube addons enable ingress`

### Create a Kubernetes Deployment File (deployment.yaml)
To tell Kubernetes which application and how many pods should be deployed a deployment configuration is necesseray. A simple `deployment.yaml` file can be found in the project folder `deployment`.
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app-deployment
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
        - name: spring-boot-app
          image: thomasdachpc/cicdguideproject:v1.0.0
          ports:
            - containerPort: 8080
```
A few comments on this file:

---
```
metadata:
	name: spring-boot-app-deployment
	namespace: default
```

Sets a unique name for the deployment and its namespace. For this guide, do not change the namespace.

---
```
replicas: 2
```
Defines how many pods of the application should be created by Kubernetes.

---
```
containers:
	- name: spring-boot-app
    	image: thomasdachpc/cicdguideproject:v1.0.0
        ports:
        	- containerPort: 8080
```
These lines of code set the application image which should be deployed by Kubernetes. The *image* is equivalent to `<docker-repository-name>:<tag>` in this case. 
The *containerPort* defines the port on which the application is accessible within the Kubernetes cluster.

---

For more information about deployments refer to the [Kubernetes documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)! 


### Create a Kubernetes Service File (service.yaml)
The next part is about the configuration of a service. Again, a simple `service.yaml` file can be found in the project folder `deployment`.
In Kubernetes, a Service is a method for exposing a network application that is running as one or more Pods in your cluster.
The first type of service we will use is the _load balancer_. It allows to access an application from the outside of the cluster.
```
apiVersion: v1
kind: Service
metadata:
  name: spring-boot-app-service
  namespace: default
spec:
  type: LoadBalancer
  selector:
    app: spring-boot-app
  ports:
    - protocol: TCP
      port: 81
      targetPort: 8080
```
A few comments on this file:

---
```
kind: Service
metadata:
	name: spring-boot-app-deployment
	namespace: default
```
Sets a unique name and the namespace for the service. For this guide, do not change the namespace.

---
```
spec:
  type: LoadBalancer
  selector:
    app: spring-boot-app
  ports:
  - protocol: TCP
    port: 81
    targetPort: 8080
```
In these lines of code the type of the service is specified as well as the application.
All traffic arriving at port 81 of the service is forwarded to port 8080 of the application _spring-boot-app_.
The name has to match the corresponding naming in the deployment file.

### Apply the configuration files
Both files can be applied to the Kubernetes cluster by executing the following commands:
```
kubectl apply -f deployment/deployment.yaml
kubectl apply -f deployment/service.yaml
```
### Check status
After applying the configuration files check the cluster status with the following command:
```
kubectl get all
```
You should see two pods as well as a service of type LoadBalancer.
Looking at the LoadBalancer service the External-IP is _\<none\>_.
To access the service and the corresponding application from outside the cluster we have to create a routable IP.
### Create a Routable IP
In another terminal window issue the following command:
``` 
minikube tunnel
```
The terminal has to stay open.\
Check the status of the cluster again.
The LoadBalancer service should now have an External-IP.
Accessing `<IP>:81` with your browser should display the known message from the RequestMapping-Method.
At this point, you have deployed an application in Kubernetes and can access it from outside the cluster!


## Creating an Ingress
[Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/) exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. 
Traffic routing is controlled by rules defined on the Ingress resource.
An Ingress may be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, 
and offer name-based virtual hosting. 
An Ingress controller is responsible for fulfilling the Ingress, usually with a load balancer, 
though it may also configure your edge router or additional frontends to help handle the traffic.

An example ingress configuration file as well as an ingress-service can be found in the deployment folder.

The service defined in the ingress-service file is similar to the previous LoadBalancber
## FluxCD

## Jenkins
Jenkins is an open-source automation server that is widely used for continuous integration (CI) and continuous delivery (CD) in software development. 
It helps automate parts of the software development process related to building, testing, and deploying applications, which leads to more efficient and reliable workflows.
To install Jenkins in your Kubernetes cluster follow sections [Kubernetes Jenkins Deployment](https://www.jenkins.io/doc/book/installing/kubernetes/#kubernetes-jenkins-deployment) 
and [Post-installation setup wizard](https://www.jenkins.io/doc/book/installing/kubernetes/#kubernetes-jenkins-deployment) of the official Jenkins handbook.